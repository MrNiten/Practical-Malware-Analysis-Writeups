# Lab Questions
1. What is the address of DllMain?
2. Use the Imports window to browse to gethostbyname. Where is the import
located?
3. How many functions call gethostbyname?
4. Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?
5. How many local variables has IDA Pro recognized for the subroutine at
0x10001656?
6. How many parameters has IDA Pro recognized for the subroutine at
0x10001656?
7. Use the Strings window to locate the string \cmd.exe /c in the disassembly.
Where is it located?
8. What is happening in the area of code that references \cmd.exe /c?
9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global
variable that helps decide which path to take. How does the malware set
dword_1008E5C4? (Hint: Use dword_1008E5C4â€™s cross-references.)
10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?
11. What does the export PSLIST do?
12. Use the graph mode to graph the cross-references from sub_10004E79.
Which API functions could be called by entering this function? Based on
the API functions alone, what could you rename this function?
13. How many Windows API functions does DllMain call directly? How many
at a depth of 2?
14. At 0x10001358, there is a call to Sleep (an API function that takes one
parameter containing the number of milliseconds to sleep). Looking
backward through the code, how long will the program sleep if this code
executes?
15. At 0x10001701 is a call to socket. What are the three parameters?
16. Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful?
What are the parameters after you apply changes?
17. Search for usage of the in instruction (opcode 0xED). This instruction is
used with a magic string VMXh to perform VMware detection. Is that in use
in this malware? Using the cross-references to the function that executes
the in instruction, is there further evidence of VMware detection?
18. Jump your cursor to 0x1001D988. What do you find?
19. If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script
provided with the malware for this book. (Make sure the cursor is at
0x1001D988.) What happens after you run the script?
20. With the cursor in the same location, how do you turn this data into a
single ASCII string?
21. Open the script with a text editor. How does it work?

# Answers
1. DLLMain resides at 1000D02E.
2. gethostbyname resides 100163CC.
3. Listing the xrefs brings up 9 calls to gethostbyname inside 5 functions.
4. A request to pics.practicalmalwareanalysis.com would be made.
5. IDA recognizes 23 local variables. They are visible above the assembly and denoted with a negative offset.
6. IDA recognizes 1 parameter, LPVOID lpthreadparameter, for this function.
7. The \cmd.exe /c string resides at 10095B34.
8. Based on the memcomp functons comparing strings like "quit, exit, cd, enmagic, idle, uptime, language, minstall, inject", the string at 1001009D "This Remote Shell Session", and the calls to the recv function, this area of code is supposed to create a remote shell.
9. At 0x10001673 there's a call to a function which returns the dwPlatformId(member of the _OSVERSIONINFOA struct) with a value of 2 denoting that the current OS is windows and at least of version 2000. The return value is stored in the EAX register and that is used to set the global variable.
10. If the string comparison to robotwork is successful, a different function is called which send()s some information stored in the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime and WorkTimes registry keys to the remote shell.
11. PSLIST checks if the OS version is older than Windows 7. Use of the library functions CreateToolHelp32Snapshot, Process32First, OpenProcess and the functions called afterward suggest this export also sends information about the currently running processes over the socket via send. It also opens a dll called "xinstall.dll".
12. This function can call GetSystemDefaultLangId and sprintf. It could be renamed GetSystemLang.
13. DLLMain calls CreateThread, strncpy, strlen, and _strnicmp directly. At depth 2, IDA shows that many, many more functions are called.
14. The program pushes an offset into the eax register which as the characters 3 and 0 at the end. It adds 13 to this offset to eax to remove the character that are not 3 and 0, uses the atoi function to change it to the integer 30 and multiplies it by 1000. 30,000 milliseconds is 30 seconds so the program would sleep for 30 seconds.
15. The three parameters are socket(2(af), 1(type), 6(protocol)).
16. 2 is specifying IPv4 addresses, 1 specifies SOCK_STREAM meaning this will be a stream of data, and 6 means it will use TCP.
17. The instruction and magic string are in use in this malware. Checking the cross references to the function this is found in, the string "Found Virtual Machine, Install Cancel." can be found in the calling functions further suggesting VMWare detection.
18. Supposedly, this is random, seemingly nonsensical data.
19. The ascii is decrypted.
20. Pressing A or using the right click menu will give you the option to turn this into a single string.
21. The script grabs the currently selected address, loops 0-50 bytes, takes the value of each byte in that range and xors it with 55. The bytes are patched in IDA's display but the original dll is left untouched.
